diff --git a/arch/arm/boot/dts/imx53-embtom.dts b/arch/arm/boot/dts/imx53-embtom.dts
new file mode 100644
index 000000000000..89aa773b0389
--- /dev/null
+++ b/arch/arm/boot/dts/imx53-embtom.dts
@@ -0,0 +1,362 @@
+/dts-v1/;
+#include "imx53.dtsi"
+
+/ {
+	model = "imx53-embtom";
+	compatible = "embtom", "fsl,imx53";
+
+	chosen {
+		stdout-path = &uart1;
+	};
+	memory@70000000 {
+		reg = <0x70000000 0x20000000>,
+		      <0xb0000000 0x20000000>;
+	};
+
+	reg_usb_otg_vbus: regulator-usb-otg-vbus {
+		pinctrl-0 = <&pinctrl_usb_otg_vbus>;
+		compatible = "regulator-fixed";
+		regulator-name = "usbotg_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio4 15 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	imx53-embtom {
+		pinctrl_nor: nor_grp{
+			fsl,pins = <
+				MX53_PAD_EIM_DA0__EMI_NAND_WEIM_DA_0	0x80000000	
+				MX53_PAD_EIM_DA1__EMI_NAND_WEIM_DA_1	0x80000000	
+				MX53_PAD_EIM_DA2__EMI_NAND_WEIM_DA_2	0x80000000
+				MX53_PAD_EIM_DA3__EMI_NAND_WEIM_DA_3	0x80000000
+				MX53_PAD_EIM_DA4__EMI_NAND_WEIM_DA_4	0x80000000
+				MX53_PAD_EIM_DA5__EMI_NAND_WEIM_DA_5	0x80000000
+				MX53_PAD_EIM_DA6__EMI_NAND_WEIM_DA_6	0x80000000
+				MX53_PAD_EIM_DA7__EMI_NAND_WEIM_DA_7	0x80000000
+				MX53_PAD_EIM_DA8__EMI_NAND_WEIM_DA_8	0x80000000
+				MX53_PAD_EIM_DA9__EMI_NAND_WEIM_DA_9	0x80000000
+				MX53_PAD_EIM_DA10__EMI_NAND_WEIM_DA_10	0x80000000
+				MX53_PAD_EIM_DA11__EMI_NAND_WEIM_DA_11	0x80000000
+				MX53_PAD_EIM_DA12__EMI_NAND_WEIM_DA_12	0x80000000
+				MX53_PAD_EIM_DA13__EMI_NAND_WEIM_DA_13	0x80000000
+				MX53_PAD_EIM_DA14__EMI_NAND_WEIM_DA_14	0x80000000
+				MX53_PAD_EIM_DA15__EMI_NAND_WEIM_DA_15	0x80000000
+				MX53_PAD_EIM_A16__EMI_WEIM_A_16			0x80000000
+				MX53_PAD_EIM_A17__EMI_WEIM_A_17			0x80000000
+				MX53_PAD_EIM_A18__EMI_WEIM_A_18			0x80000000
+				MX53_PAD_EIM_A19__EMI_WEIM_A_19			0x80000000
+				MX53_PAD_EIM_A20__EMI_WEIM_A_20			0x80000000
+				MX53_PAD_EIM_A21__EMI_WEIM_A_21			0x80000000
+				MX53_PAD_EIM_A22__EMI_WEIM_A_22			0x80000000
+				MX53_PAD_EIM_A23__EMI_WEIM_A_23			0x80000000
+				MX53_PAD_EIM_A24__EMI_WEIM_A_24			0x80000000
+				MX53_PAD_EIM_A25__EMI_WEIM_A_25			0x80000000
+				MX53_PAD_EIM_D16__EMI_WEIM_D_16			0x80000000
+				MX53_PAD_EIM_D17__EMI_WEIM_D_17			0x80000000
+				MX53_PAD_EIM_D18__EMI_WEIM_D_18			0x80000000
+				MX53_PAD_EIM_D19__EMI_WEIM_D_19			0x80000000
+				MX53_PAD_EIM_D20__EMI_WEIM_D_20			0x80000000
+				MX53_PAD_EIM_D21__EMI_WEIM_D_21			0x80000000
+				MX53_PAD_EIM_D22__EMI_WEIM_D_22			0x80000000
+				MX53_PAD_EIM_D23__EMI_WEIM_D_23			0x80000000
+				MX53_PAD_EIM_D24__EMI_WEIM_D_24			0x80000000
+				MX53_PAD_EIM_D25__EMI_WEIM_D_25			0x80000000
+				MX53_PAD_EIM_D26__EMI_WEIM_D_26			0x80000000
+				MX53_PAD_EIM_D27__EMI_WEIM_D_27			0x80000000
+				MX53_PAD_EIM_D28__EMI_WEIM_D_28			0x80000000
+				MX53_PAD_EIM_D29__EMI_WEIM_D_29			0x80000000
+				MX53_PAD_EIM_D30__EMI_WEIM_D_30			0x80000000
+				MX53_PAD_EIM_D31__EMI_WEIM_D_31			0x80000000
+				MX53_PAD_EIM_CS0__EMI_WEIM_CS_0			0x80000000
+				MX53_PAD_EIM_EB0__EMI_WEIM_EB_0			0x80000000
+				MX53_PAD_EIM_EB1__EMI_WEIM_EB_1			0x80000000
+				MX53_PAD_EIM_LBA__EMI_WEIM_LBA			0x80000000
+				MX53_PAD_EIM_OE__EMI_WEIM_OE			0x80000000
+				MX53_PAD_EIM_RW__EMI_WEIM_RW			0x80000000
+				MX53_PAD_EIM_WAIT__EMI_WEIM_WAIT		0x80000000
+			>;
+		};
+	/*	pinctrl_fec: fexgrp {
+			fsl,pins = <
+				MX53_PAD_FEC_MDIO__FEC_MDIO			0x800001fc
+				MX53_PAD_FEC_MDC__FEC_MDC       	0x80000004
+				MX53_PAD_FEC_RXD1__FEC_RDATA_1		0x80000180
+				MX53_PAD_FEC_RXD0__FEC_RDATA_0  	0x80000180
+				MX53_PAD_FEC_TXD1__FEC_TDATA_1  	0x80000004
+				MX53_PAD_FEC_TXD0__FEC_TDATA_0  	0x80000004
+				MX53_PAD_FEC_TX_EN__FEC_TX_EN   	0x80000004
+				MX53_PAD_FEC_REF_CLK__FEC_TX_CLK  	0x80000180
+				MX53_PAD_FEC_RX_ER__FEC_RX_ER		0x80000180
+				MX53_PAD_KEY_COL3__FEC_CRS			0x80000180
+				MX53_PAD_FEC_MDIO__FEC_COL			0x80000180
+				MX53_PAD_FEC_CRS_DV__FEC_RX_DV      0x80000180
+				MX53_PAD_KEY_COL1__FEC_RX_CLK		0x80000180
+			>;
+		};*/
+		pinctrl_can1: can1grp {
+			fsl,pins = <
+				MX53_PAD_GPIO_7__CAN1_TXCAN  		0x800001ed
+				MX53_PAD_GPIO_8__CAN1_RXCAN         0x800001ed
+			>;
+		};
+		pinctrl_can2: can2grp {
+			fsl,pins = <
+				MX53_PAD_PATA_RESET_B__CAN2_TXCAN  	0x800001ed
+				MX53_PAD_PATA_IORDY__CAN2_RXCAN     0x800001ed
+			>;
+		};
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = < 
+				MX53_PAD_CSI0_DAT4__ECSPI1_SCLK		0x1e4
+				MX53_PAD_CSI0_DAT5__ECSPI1_MOSI     0x1e4
+				MX53_PAD_CSI0_DAT6__ECSPI1_MISO		0x1e4
+				MX53_PAD_CSI0_DAT7__GPIO5_25		0x1e4 
+			>;
+		};
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX53_PAD_PATA_DMACK__UART1_RXD_MUX  0x1e4
+				MX53_PAD_PATA_DIOW__UART1_TXD_MUX   0x1e4
+			>;
+		};
+		pinctrl_uart2: uart2grp{
+			fsl,pins = <
+				MX53_PAD_PATA_BUFFER_EN__UART2_RXD_MUX  0x1e4
+				MX53_PAD_PATA_DMARQ__UART2_TXD_MUX   0x1e4
+			>;
+		};
+		pinctrl_uart3: uart3grp{
+			fsl,pins = <
+				MX53_PAD_PATA_CS_1__UART3_RXD_MUX  	0x1e4
+				MX53_PAD_PATA_CS_0__UART3_TXD_MUX   0x1e4
+			>;
+		};
+		pinctrl_i2c1:i2c1grp{
+			fsl,pins = <
+				MX53_PAD_CSI0_DAT8__I2C1_SDA 0xc0000000
+				MX53_PAD_CSI0_DAT9__I2C1_SCL 0xc0000000 
+			>;
+		};
+
+		pinctrl_usb_otg_vbus: usb-otg-vbusgrp {
+			fsl,pins = <
+				/* USB_HS_OTG_VBUS_ENABLE */
+				MX53_PAD_KEY_ROW4__GPIO4_15		0x1c4
+			>;
+		};
+
+		pinctrl_usb_otg: usbotggrp {
+			fsl,pins = <
+				/* USB_OTG_FAULT_N */
+				MX53_PAD_KEY_COL4__USBOH3_USBOTG_OC	0x180
+			>;
+		};
+	};
+};
+
+&weim {
+    compatible = "fsl,imx50-weim";
+    ranges = <0 0 0xf0000000 0x08000000>;
+    fsl,weim-cs-gpr = <&pinctrl_nor>;
+    status = "okay";
+
+    nor@0,0 {
+        compatible = "cfi-flash";
+        reg = <0 0 0x8000000>;
+        #address-cells = <1>;
+        #size-cells = <1>;
+        bank-width = <2>;
+		fsl,weim-cs-timing = <0x10320281 0x00001002 0x0e020000
+				0x0000a000 0x07000000 0x00000000>;
+        status = "okay";
+		
+        partition@0 {
+			reg = <0xC0000 0x20000>;
+			label = "nor.uboot.env";
+            read-only;
+		};
+
+		partition@40000 {
+			reg = <0x100000 0x500000>;
+			label = "nor.kernel";
+			read-only;
+		};
+
+		partition@900000 {
+			reg = <0x600000 0x3A00000>;			/* reduced to a total of 55MB for faster rootfs update, max possible size +64MB */ 
+			label = "nor.rootfs";
+		};
+    };
+};
+
+&fec {
+	pinctrl-names = "default";
+	/*pinctrl-0 = <&pinctrl_fec>; */
+	phy-reset-gpios = <&gpio4 7 GPIO_ACTIVE_LOW>;
+	phy-mode = "rmii";
+	status = "okay";
+};
+
+&can1 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_can1>;
+    status = "okay";
+};
+
+&can2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_can2>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_i2c1>;
+	clock-frequency = <100000>;
+	status = "okay";
+	rtc@68 {
+		compatible = "dallas,ds1307";
+		reg = <0x68>;
+		trickle-diode-disable = <1>;
+		trickle-resistor-ohms = <250>;
+	};
+	adc@48 {
+		compatible = "ti,ads1015";
+		reg = <0x48>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		channel@1 {
+			reg = <4>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@2 {
+			reg = <5>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@3 {
+			reg = <6>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@4 {
+			reg = <7>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+	};
+	adc@49 {
+		compatible = "ti,ads1015";
+		reg = <0x49>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		channel@1 {
+			reg = <4>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@2 {
+			reg = <5>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@3 {
+			reg = <6>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@4 {
+			reg = <7>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+	};
+	adc@4a {
+		compatible = "ti,ads1015";
+		reg = <0x4a>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		channel@1 {
+			reg = <4>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@2 {
+			reg = <5>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@3 {
+			reg = <6>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+		channel@4 {
+			reg = <7>;
+			ti,gain = <1>;
+			ti,datarate = <2>;
+		};
+	};
+};
+
+&ecspi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	cs-gpios = <&gpio5 25 GPIO_ACTIVE_LOW>;
+	status = "okay";	
+/*	m25_eeprom: m25p80@0 {
+		compatible = "atmel,at25256B", "atmel,at25";
+		spi-max-frequency = <5000000>;
+		size = <8192>;
+		pagesize = <64>;
+		reg = <0>;
+		address-width = <16>;
+	};*/
+
+	fm25@0  {
+		compatible = "fm25";
+		size = <8192>;
+		pagesize = <1>;
+		address-width = <16>;
+		spi-max-frequency = <5000000>;
+		reg = <0>;
+	};
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb_otg>;
+	vbus-supply = <&reg_usb_otg_vbus>;
+	disable-over-current;
+	dr_mode = "host";
+	phy_type = "utmi";
+	status = "okay";
+};
+
+/*&usbh1 {
+	vbus-supply = <&reg_usb_vbus>;
+	status = "okay";
+};*/
\ No newline at end of file
diff --git a/arch/arm/boot/dts/imx53.dtsi b/arch/arm/boot/dts/imx53.dtsi
index 207eb557c90e..913e45fcc844 100644
--- a/arch/arm/boot/dts/imx53.dtsi
+++ b/arch/arm/boot/dts/imx53.dtsi
@@ -785,6 +785,15 @@
 				status = "disabled";
 			};
 
+			weim: weim@63fda000 {
+				#address-cells = <2>;
+				#size-cells = <1>;
+				compatible = "fsl,imx50-weim";
+				reg = <0x63fda000 0x1000>;
+				clocks = <&clks IMX5_CLK_EMI_SLOW_GATE>;
+				status = "disabled";
+			};
+
 			fec: ethernet@63fec000 {
 				compatible = "fsl,imx53-fec", "fsl,imx25-fec";
 				reg = <0x63fec000 0x4000>;
diff --git a/drivers/hwmon/ads1015.c b/drivers/hwmon/ads1015.c
index 98c704d3366a..6a0cbd0b1435 100644
--- a/drivers/hwmon/ads1015.c
+++ b/drivers/hwmon/ads1015.c
@@ -286,7 +286,7 @@ static int ads1015_probe(struct i2c_client *client,
 			goto exit_remove;
 	}
 
-	data->hwmon_dev = hwmon_device_register(&client->dev);
+	data->hwmon_dev = hwmon_device_register_with_info(&client->dev, &client->name[0], NULL, NULL, NULL);		
 	if (IS_ERR(data->hwmon_dev)) {
 		err = PTR_ERR(data->hwmon_dev);
 		goto exit_remove;
diff --git a/drivers/misc/eeprom/Kconfig b/drivers/misc/eeprom/Kconfig
index fe7a1d27a017..e8124f8702e3 100644
--- a/drivers/misc/eeprom/Kconfig
+++ b/drivers/misc/eeprom/Kconfig
@@ -41,6 +41,18 @@ config EEPROM_AT25
 	  This driver can also be built as a module.  If so, the module
 	  will be called at25.
 
+config FRAM_FM25
+	tristate "SPI Cypress FRAM"
+	depends on SPI && SYSFS
+	help
+	  Enable this driver to get read/write support to SPI FRAMs,
+	  after you configure the board init code to know about each fram
+	  on your target board.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called fm25.
+
+
 config EEPROM_LEGACY
 	tristate "Old I2C EEPROM reader"
 	depends on I2C && SYSFS
diff --git a/drivers/misc/eeprom/Makefile b/drivers/misc/eeprom/Makefile
index a9b4b6579b75..1bb25e2a607c 100644
--- a/drivers/misc/eeprom/Makefile
+++ b/drivers/misc/eeprom/Makefile
@@ -1,6 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_EEPROM_AT24)	+= at24.o
 obj-$(CONFIG_EEPROM_AT25)	+= at25.o
+obj-$(CONFIG_FRAM_FM25)		+= fm25.o
+CFLAGS_fm25.o += -O0
 obj-$(CONFIG_EEPROM_LEGACY)	+= eeprom.o
 obj-$(CONFIG_EEPROM_MAX6875)	+= max6875.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
diff --git a/drivers/misc/eeprom/fm25.c b/drivers/misc/eeprom/fm25.c
new file mode 100644
index 000000000000..3b09943a7620
--- /dev/null
+++ b/drivers/misc/eeprom/fm25.c
@@ -0,0 +1,489 @@
+/*
+ * fm25.c -- support SPI FRAMs, such as Cypress FM25 models
+ *
+ * Copyright (C) 2014 Jiri Prchal
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/nvmem-provider.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/of.h>
+
+struct fm25_data {
+	struct spi_device	    *spi;
+	struct mutex		    lock;
+	struct spi_eeprom	    chip;
+	unsigned		        addrlen;
+	int			            has_sernum;
+    struct regmap_config	regmap_config;
+	struct nvmem_config	    nvmem_config;
+	struct nvmem_device	    *nvmem;
+};
+
+#define	FM25_WREN	0x06		/* latch the write enable */
+#define	FM25_WRDI	0x04		/* reset the write enable */
+#define	FM25_RDSR	0x05		/* read status register */
+#define	FM25_WRSR	0x01		/* write status register */
+#define	FM25_READ	0x03		/* read byte(s) */
+#define	FM25_WRITE	0x02		/* write byte(s)/sector */
+#define	FM25_SLEEP	0xb9		/* enter sleep mode */
+#define	FM25_RDID	0x9f		/* read device ID */
+#define	FM25_RDSN	0xc3		/* read S/N */
+
+#define	FM25_SR_WEN	0x02		/* write enable (latched) */
+#define	FM25_SR_BP0	0x04		/* BP for software writeprotect */
+#define	FM25_SR_BP1	0x08
+#define	FM25_SR_WPEN	0x80		/* writeprotect enable */
+
+#define FM25_ID_LEN	9		/* ID lenght */
+#define FM25_SN_LEN	8		/* serial number lenght */
+
+#define FM25_MAXADDRLEN	3		/* 24 bit addresses */
+
+#define	io_limit	PAGE_SIZE	/* bytes */
+
+static ssize_t fm25_data_read(struct fm25_data *fm25, char *buf, unsigned offset, size_t count)
+{
+	u8			command[FM25_MAXADDRLEN + 1];
+	u8			*cp;
+	ssize_t			status;
+	struct spi_transfer	t[2];
+	struct spi_message	m;
+	u8			instr;
+
+	if (unlikely(offset >= fm25->chip.byte_len))
+		return 0;
+	if ((offset + count) > fm25->chip.byte_len)
+		count = fm25->chip.byte_len - offset;
+	if (unlikely(!count))
+		return count;
+
+	cp = command;
+
+	instr = FM25_READ;
+	*cp++ = instr;
+
+	/* 8/16/24-bit address is written MSB first */
+	switch (fm25->addrlen) {
+	default:	/* case 3 */
+		*cp++ = offset >> 16;
+	case 2:
+		*cp++ = offset >> 8;
+	case 1:
+	case 0:	/* can't happen: for better codegen */
+		*cp++ = offset >> 0;
+	}
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof t);
+
+	t[0].tx_buf = command;
+	t[0].len = fm25->addrlen + 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = count;
+	spi_message_add_tail(&t[1], &m);
+
+	mutex_lock(&fm25->lock);
+
+	/* Read it all at once.
+	 *
+	 * REVISIT that's potentially a problem with large chips, if
+	 * other devices on the bus need to be accessed regularly or
+	 * this chip is clocked very slowly
+	 */
+	status = spi_sync(fm25->spi, &m);
+	dev_dbg(&fm25->spi->dev,
+		"read %Zd bytes at %d --> %d\n",
+		count, offset, (int) status);
+
+	mutex_unlock(&fm25->lock);
+	return status ? status : count;
+}
+
+static ssize_t fm25_id_read(struct fm25_data *fm25, char *buf)
+{
+	u8			command = FM25_RDID;
+	ssize_t			status;
+	struct spi_transfer	t[2];
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof t);
+
+	t[0].tx_buf = &command;
+	t[0].len = 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = FM25_ID_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	mutex_lock(&fm25->lock);
+
+	status = spi_sync(fm25->spi, &m);
+	dev_dbg(&fm25->spi->dev, "read %Zd bytes of ID --> %d\n", FM25_ID_LEN, (int) status);
+
+	mutex_unlock(&fm25->lock);
+	return status ? status : FM25_ID_LEN;
+}
+
+static ssize_t fm25_sernum_read(struct fm25_data *fm25, char *buf)
+{
+	u8			command = FM25_RDSN;
+	ssize_t			status;
+	struct spi_transfer	t[2];
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof t);
+
+	t[0].tx_buf = &command;
+	t[0].len = 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = FM25_SN_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	mutex_lock(&fm25->lock);
+
+	status = spi_sync(fm25->spi, &m);
+	dev_dbg(&fm25->spi->dev,
+		"read %Zd bytes of serial number --> %d\n",
+		FM25_SN_LEN, (int) status);
+
+	mutex_unlock(&fm25->lock);
+	return status ? status : FM25_SN_LEN;
+}
+
+static ssize_t sernum_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char			binbuf[FM25_SN_LEN];
+	struct fm25_data	*fm25;
+	int			i;
+	char			*pbuf = buf;
+
+	fm25 = dev_get_drvdata(dev);
+	fm25_sernum_read(fm25, binbuf);
+	for (i = 0; i < FM25_SN_LEN; i++)
+		pbuf += sprintf(pbuf, "%02x ", binbuf[i]);
+	sprintf(--pbuf, "\n");
+	return (3 * i);
+}
+static const DEVICE_ATTR_RO(sernum);
+
+static int fm25_regmap_read(void *context, const void *reg, size_t reg_size, void *val, size_t val_size)
+{
+	struct fm25_data *fm25 = context;
+	off_t offset = *(u32 *)reg;
+	int err;
+
+	err = fm25_data_read(fm25, val, offset, val_size);
+	if (err)
+		return err;
+	return 0;
+}
+
+static ssize_t fm25_data_write(struct fm25_data *fm25, const char *buf, loff_t off, size_t count)
+{
+	ssize_t			status = 0;
+	unsigned		written = 0;
+	unsigned		buf_size;
+	u8			*bounce;
+
+	if (unlikely(off >= fm25->chip.byte_len))
+		return -EFBIG;
+	if ((off + count) > fm25->chip.byte_len)
+		count = fm25->chip.byte_len - off;
+	if (unlikely(!count))
+		return count;
+
+	/* Temp buffer starts with command and address */
+	buf_size = io_limit;
+	bounce = kmalloc(buf_size + fm25->addrlen + 1, GFP_KERNEL);
+	if (!bounce)
+		return -ENOMEM;
+
+	/* For write, rollover is within the page ... so we write at
+	 * most one page, then manually roll over to the next page.
+	 */
+	mutex_lock(&fm25->lock);
+	do {
+		unsigned	segment;
+		unsigned	offset = (unsigned) off;
+		u8		*cp = bounce;
+		u8		instr;
+
+		*cp = FM25_WREN;
+		status = spi_write(fm25->spi, cp, 1);
+		if (status < 0) {
+			dev_dbg(&fm25->spi->dev, "WREN --> %d\n",
+					(int) status);
+			break;
+		}
+
+		instr = FM25_WRITE;
+		*cp++ = instr;
+
+		/* 8/16/24-bit address is written MSB first */
+		switch (fm25->addrlen) {
+		default:	/* case 3 */
+			*cp++ = offset >> 16;
+		case 2:
+			*cp++ = offset >> 8;
+		case 1:
+		case 0:	/* can't happen: for better codegen */
+			*cp++ = offset >> 0;
+		}
+
+		/* Write as much of a page as we can */
+		segment = buf_size - (offset % buf_size);
+		if (segment > count)
+			segment = count;
+		memcpy(cp, buf, segment);
+		status = spi_write(fm25->spi, bounce,
+				segment + fm25->addrlen + 1);
+		dev_dbg(&fm25->spi->dev,
+				"write %u bytes at %u --> %d\n",
+				segment, offset, (int) status);
+		if (status < 0)
+			break;
+
+		/* REVISIT this should detect (or prevent) failed writes
+		 * to readonly sections of the EEPROM...
+		 */
+
+		off += segment;
+		buf += segment;
+		count -= segment;
+		written += segment;
+
+	} while (count > 0);
+
+	mutex_unlock(&fm25->lock);
+
+	kfree(bounce);
+	return written ? written : status;
+}
+
+static int fm25_regmap_write(void *context, const void *data, size_t count)
+{
+	struct fm25_data *fm25 = context;
+	const char *buf;
+	u32 offset;
+	size_t len;
+	int err;
+
+	memcpy(&offset, data, sizeof(offset));
+	buf = (const char *)data + sizeof(offset);
+	len = count - sizeof(offset);
+
+    err = fm25_data_write(fm25, buf, offset, len);
+	if (err)
+		return err;
+	return 0;
+}
+
+static const struct regmap_bus fm25_regmap_bus = {
+	.read = fm25_regmap_read,
+	.write = fm25_regmap_write,
+	.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Let in-kernel code access the eeprom data. */
+
+// static ssize_t fm25_mem_read(struct memory_accessor *mem, char *buf,
+// 			     off_t offset, size_t count)
+// {
+//   struct fm25_data *fm25 = container_of(mem, struct fm25_data, mem);
+
+//   return fm25_data_read(fm25, buf, offset, count);
+// }
+
+// static ssize_t fm25_mem_write(struct memory_accessor *mem, const char *buf,
+// 			  off_t offset, size_t count)
+// {
+// 	struct fm25_data *fm25 = container_of(mem, struct fm25_data, mem);
+
+// 	return fm25_data_write(fm25, buf, offset, count);
+// }
+
+/*-------------------------------------------------------------------------*/
+
+static int fm25_np_to_chip(struct device *dev, struct device_node *np, struct spi_eeprom *chip)
+{
+	memset(chip, 0, sizeof(*chip));
+	strncpy(chip->name, np->name, sizeof(chip->name));
+
+	if (of_find_property(np, "read-only", NULL))
+		chip->flags |= EE_READONLY;
+	return 0;
+}
+
+static int fm25_probe(struct spi_device *spi)
+{
+	struct fm25_data	*fm25 = NULL;
+	struct spi_eeprom	chip;
+    struct regmap		*regmap;
+	struct device_node	*np = spi->dev.of_node;
+	int	        		err;
+	char			id[FM25_ID_LEN];
+
+	/* Chip description */
+	if (!spi->dev.platform_data) {
+		if (np) {
+			err = fm25_np_to_chip(&spi->dev, np, &chip);
+			if (err)
+				return err;
+		} else {
+			dev_err(&spi->dev, "Error: no chip description\n");
+			return -ENODEV;
+		}
+	} else
+		chip = *(struct spi_eeprom *)spi->dev.platform_data;
+
+	fm25 = devm_kzalloc(&spi->dev, sizeof(struct fm25_data), GFP_KERNEL);
+	if (!fm25)
+		return -ENOMEM;
+
+	mutex_init(&fm25->lock);
+	fm25->chip = chip;
+	fm25->spi = spi_dev_get(spi);
+	spi_set_drvdata(spi, fm25);
+
+	/* Get ID of chip */
+	fm25_id_read(fm25, id);
+	if (id[6] != 0xc2) {
+		dev_err(&spi->dev, "Error: no Cypress FRAM (id %02x)\n", id[6]);
+		return -ENODEV;
+	}
+	/* set size found in ID */
+	switch (id[7]) {
+		case 0x21:
+			fm25->chip.byte_len = 16 * 1024;
+			break;
+		case 0x22:
+			fm25->chip.byte_len = 32 * 1024;
+			break;
+		case 0x23:
+			fm25->chip.byte_len = 64 * 1024;
+			break;
+		case 0x24:
+			fm25->chip.byte_len = 128 * 1024;
+			break;
+		case 0x25:
+			fm25->chip.byte_len = 256 * 1024;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Error: unsupported size (id %02x)\n", id[7]);
+			return -ENODEV;
+			break;
+	}
+
+	if (fm25->chip.byte_len > 64 * 1024) {
+		fm25->addrlen = 3;
+		fm25->chip.flags |= EE_ADDR3;
+	}
+	else {
+		fm25->addrlen = 2;
+		fm25->chip.flags |= EE_ADDR2;
+	}
+
+	if (id[8])
+		fm25->has_sernum = 1;
+	else
+		fm25->has_sernum = 0;
+
+	fm25->regmap_config.reg_bits = 32;
+	fm25->regmap_config.val_bits = 8;
+	fm25->regmap_config.reg_stride = 1;
+	fm25->regmap_config.max_register = chip.byte_len - 1;
+
+	regmap = devm_regmap_init(&spi->dev, &fm25_regmap_bus, fm25, &fm25->regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&spi->dev, "regmap init failed\n");
+		return PTR_ERR(regmap);
+	}
+
+    fm25->nvmem_config.name = dev_name(&spi->dev);
+	fm25->nvmem_config.dev = &spi->dev;
+	fm25->nvmem_config.read_only = chip.flags & EE_READONLY;
+	fm25->nvmem_config.root_only = true;
+	fm25->nvmem_config.owner = THIS_MODULE;
+	fm25->nvmem_config.compat = true;
+	fm25->nvmem_config.base_dev = &spi->dev;
+
+
+
+	/* Export the FM25 serial number */
+	if (fm25->has_sernum) {
+		err = device_create_file(&spi->dev, &dev_attr_sernum);
+		if (err)
+			return err;
+	}
+
+	//if (chip.setup)
+	//	chip.setup(&fm25->mem, chip.context);
+
+	dev_info(&spi->dev, "%Zd %s %s fram%s\n",
+		(chip.byte_len < 1024) ? chip.byte_len: (chip.byte_len / 1024),
+		(chip.byte_len < 1024) ? "Byte" : "KByte",
+		fm25->chip.name,
+		(chip.flags & EE_READONLY) ? " (readonly)" : "");
+
+	return 0;
+}
+
+static int fm25_remove(struct spi_device *spi)
+{
+	struct fm25_data	*fm25;
+
+	fm25 = spi_get_drvdata(spi);
+	nvmem_unregister(fm25->nvmem);
+	if (fm25->has_sernum)
+		device_remove_file(&spi->dev, &dev_attr_sernum);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct of_device_id fm25_of_match[] = {
+	{ .compatible = "fm25", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, fm25_of_match);
+
+static struct spi_driver fm25_driver = {
+	.driver = {
+		.name		= "fm25",
+		.owner		= THIS_MODULE,
+		.of_match_table = fm25_of_match,
+	},
+	.probe		= fm25_probe,
+	.remove		= fm25_remove,
+};
+
+module_spi_driver(fm25_driver);
+
+MODULE_DESCRIPTION("Driver for Cypress SPI FRAMs");
+MODULE_AUTHOR("Jiri Prchal");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:fram");
\ No newline at end of file
diff --git a/firmware/imx/sdma/sdma-imx53.bin b/firmware/imx/sdma/sdma-imx53.bin
new file mode 100644
index 000000000000..34933b1a2333
Binary files /dev/null and b/firmware/imx/sdma/sdma-imx53.bin differ
